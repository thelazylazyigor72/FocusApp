{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./quote.js","webpack:///./todo.js","webpack:///./timer.js"],"sourcesContent":["import './style.scss'\r\n//!DOMContentLoaded\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    //loading quote when page load\r\n    generateQuote(quoteURL)\r\n})\r\n\r\n//!get container for quote\r\nconst quoteContainer = document.querySelector('.quote')\r\n//!get container for author\r\nconst authorContainer = document.querySelector('.quote_author')\r\n//!get btn dat will generate new quote\r\nconst quoteGenerate = document.querySelector('.btn_gen_quote')\r\n\r\n//!generating quote by clicking\r\nquoteGenerate.addEventListener('click', () => {\r\n    generateQuote(quoteURL)\r\n    /*old version w/ promises\r\n    generateQuoteProm(quoteURL)\r\n    .then(response => response.json())\r\n    .then(data => console.log(data))*/\r\n})\r\n\r\n//!addres of quote api\r\nconst quoteURL = 'https://api.quotable.io/random'\r\n\r\n//!function dat doing request and get random quotes data\r\n//!and then assign it to containers\r\nconst generateQuote = async src => {\r\n    let response = await fetch(src)\r\n    let data = await response.json()\r\n    quoteContainer.textContent = data.content\r\n    authorContainer.textContent = data.author\r\n}\r\n\r\nconsole.log('hello from quote')\r\n/*old version w/promises\r\nconst generateQuoteProm = (src) => {\r\n    return fetch(src)\r\n}*/\r\n//localStorage.clear()\r\n","//?GETTING ELEMENTS--------------------------------------------------------------------------------------------------------------------------\r\n//!get input field\r\nconst inputField = document.querySelector('#input')\r\n//!get btn that creates task in list based on input\r\nconst pullToList = document.querySelector('.btn_add')\r\n//!get container where tasks should be \r\nconst tasksContainer = document.querySelector('.todo_list')\r\n//!get container where done tasks should be\r\nconst tasksContainerDone = document.querySelector('.todo_list_done')\r\n//!get clear done tasks btn\r\nconst clearDoneTasks = document.querySelector('.btn_clear_done')\r\n/*\r\n?Issue was founded, if key=value in localStorage, then localStorage start to give no fucks to order of pairs in storage\r\nSo i decided to create function dat creates unique key for each task and dat key is growing up lineary, so basically\r\ni get pairs like 1:value1 , 2:value2, etc.\r\n!functions below is based on Closure concept, and checking of localStorage keys, so i get what i want\r\n*/\r\n\r\n//?FUCTIONS----------------------------------------------------------------------------------------------------------------------------------\r\n//!generate unique key for active tasks\r\nconst generateUniqueKey = () => {\r\n    //this count changin 'on the spot' - according to closure theory\r\n    let count = 0;\r\n    //inside we check, if lS is empty then we start from 0, else we start from max key+1 to keep the growing order\r\n    return function() {\r\n        if (localStorage.length === 0) {\r\n        return count\r\n        } else {\r\n        let keysStore = Object.keys(localStorage)\r\n        let higherKey = Math.max(...keysStore)\r\n        return count = higherKey + 1\r\n        }\r\n    }\r\n}\r\n\r\n//!generate negative unique key for done tasks\r\nconst generateNegativeUniqueKey = () => {\r\n    //this count changin 'on the spot' - according to closure theory\r\n    let count = 0;\r\n    //inside we check, if length 0 or 1 we call -1 else we get lower key and decreasing it\r\n    return function() {\r\n        if (localStorage.length <= 1) {\r\n        return count - 1\r\n        } else {\r\n        let keysStore = Object.keys(localStorage)\r\n        let lowerKey = Math.min(...keysStore)\r\n        return count = lowerKey - 1\r\n        }\r\n    }\r\n}\r\n\r\n//!assign call of function to make the Closure\r\nlet counter = generateUniqueKey()\r\n\r\n//!assign call of function to make the Closure\r\nlet counterNegative = generateNegativeUniqueKey()\r\n\r\n//!function dat populate active task as html element on page\r\nconst populateTask = input => {\r\n    const HTMLCode = `                \r\n            <p class=\"task_text\">${input}</p>\r\n            <div class=\"controls\">\r\n            <button class=\"btn btn_check\">\r\n                <i class=\"fas fa-check\"></i>\r\n            </button>\r\n            <button class=\"btn btn_times\">\r\n                <i class=\"fas fa-times\"></i>\r\n            </button>\r\n            </div>`\r\n    new Task(HTMLCode).populateTasks()\r\n}\r\n\r\n//!function dat repopulate done task as html element to their container on page\r\nconst populateDoneTask = input => {\r\n    const HTMLCode = `                \r\n    <p class=\"task_text_done\">${input}</p>`\r\n    new Task(HTMLCode).populateDoneTasks(input)\r\n}\r\n\r\n//!function to put functionality on buttons accordin to passed task\r\nconst initBtns = lazyTask => {\r\n        //!get chech task btn \r\n        const doneTask = lazyTask.querySelector('.btn_check')\r\n        //!get delete task btn\r\n        const deleteTask = lazyTask.querySelector('.btn_times')\r\n        //!get task text \r\n        const taskText = lazyTask.querySelector('.task_text')\r\n    \r\n        doneTask.addEventListener('click', (e) => {\r\n            e.preventDefault()\r\n\r\n            //!marking task as completed\r\n            taskText.classList.toggle('btn_check_show')\r\n            let savedTaskText = taskText.textContent\r\n            populateDoneTask(savedTaskText)\r\n            deleteNodeTask(e)\r\n        })\r\n    \r\n        deleteTask.addEventListener('click', (e) => {\r\n            //pass event to function that delete node based on coming event\r\n            deleteNodeTask(e)\r\n        })\r\n}\r\n\r\n//!function dat populates back all stored tasks to the page when page re/loads\r\n//idea that we take all ordered keys of localStorage and based on them bringing all elements back\r\nconst repopulateTasks = () => {\r\n    //sorting keys, so we keep the order\r\n    let store = Object.keys(localStorage)\r\n    //! takin all positive keys (positive - actual)\r\n    store = store.filter(x => x > -1)\r\n    store = store.sort()\r\n    //console.log(store)\r\n    for (let i = 0; i < store.length; i++) {\r\n        const value = localStorage.getItem(store[i]);\r\n        const taskNodeRe = document.createElement('li')\r\n        taskNodeRe.classList.add('task')\r\n        taskNodeRe.dataset.key = store[i]\r\n        const skeleton = `                \r\n        <p class=\"task_text\">${value}</p>\r\n        <div class=\"controls\">\r\n            <button class=\"btn btn_check\">\r\n            <i class=\"fas fa-check\"></i>\r\n            </button>\r\n            <button class=\"btn btn_times\">\r\n            <i class=\"fas fa-times\"></i>\r\n            </button>\r\n        </div>`\r\n        taskNodeRe.innerHTML = skeleton\r\n        //console.log(taskNodeRe)\r\n        tasksContainer.append(taskNodeRe)\r\n    }\r\n    //!get collection of just created lists-tasks and go thru it and for each task bring back her btns functionality \r\n    const taskCollection = document.querySelectorAll('.task')\r\n    taskCollection.forEach(task => {\r\n        initBtns(task)\r\n    })\r\n}\r\n\r\n//!function dat populates back all done tasks to the page\r\nconst repopulateDoneTasks = () => {\r\n    //sorting keys, so we keep the order\r\n    let store = Object.keys(localStorage)\r\n    //! takin all positive keys (negative - done)\r\n    store = store.filter(x => x < 0)\r\n    store = store.sort()\r\n    //console.log(store)\r\n    for (let i = 0; i < store.length; i++) {\r\n        const value = localStorage.getItem(store[i]);\r\n        const taskNodeRe = document.createElement('li')\r\n        taskNodeRe.classList.add('task')\r\n        taskNodeRe.dataset.key = store[i]\r\n        const skeleton = `                \r\n        <p class=\"task_text_done\">${value}</p>`\r\n        taskNodeRe.innerHTML = skeleton\r\n        //console.log(taskNodeRe)\r\n        tasksContainerDone.append(taskNodeRe)\r\n    }\r\n}\r\n\r\n//!function that deletes node based on what we clicking\r\nconst deleteNodeTask = (event) => {\r\n    let target = event.currentTarget.parentNode.parentNode\r\n    if (target.classList.contains('task')) {\r\n        target.remove()\r\n        target.classList.remove('task')\r\n        localStorage.removeItem(target.dataset.key)\r\n    } else {\r\n        alert('Error when deleting')\r\n    }\r\n}\r\n\r\n//!event on pullToList, so when we click it we create html element\r\npullToList.addEventListener('click', () => {\r\n    if (inputField.value) {\r\n        populateTask(inputField.value)\r\n        inputField.value = ''\r\n    } else {\r\n        alert('Ты ничего не вводишь')\r\n    }\r\n})\r\n\r\n//!event when we press enter, then we pass the value\r\ninputField.addEventListener('keyup', e => {\r\n    if (e.keyCode === 13 && inputField.value != '') {\r\n        populateTask(inputField.value)\r\n        inputField.value = ''\r\n    }\r\n})\r\n\r\n//!When page re/loads whe need to populate all active  and done tasks back to view\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    repopulateTasks()\r\n    repopulateDoneTasks()\r\n})\r\n\r\n//!Delete done tasks\r\nclearDoneTasks.addEventListener('click', () => {\r\n    //!Clear only there's no active tasks\r\n    let store = Object.keys(localStorage)\r\n    store = store.filter(x => x >= 0)\r\n    if (store.length === 0) {\r\n        const taskCollection = document.querySelectorAll('.task')\r\n        taskCollection.forEach(task => {\r\n            if (Number(task.dataset.key) < 0) {\r\n                task.remove()\r\n                task.classList.remove('task')\r\n                localStorage.removeItem(task.dataset.key)\r\n            }\r\n        })\r\n    } else {\r\n        alert('U can clear stash only when u did everything, sorry we working on it')\r\n    }\r\n\r\n})\r\n\r\n//!Class to make tasks\r\nclass Task {\r\n    constructor(HTMLCode) {\r\n        this.HTMLCode = HTMLCode;\r\n    }\r\n\r\n    populateTasks() {\r\n        const inpVal = inputField.value\r\n        const taskNode = document.createElement('li')\r\n        taskNode.classList.add('task')\r\n        taskNode.dataset.key = counter()\r\n        taskNode.innerHTML = this.HTMLCode\r\n        tasksContainer.append(taskNode)\r\n        localStorage.setItem(counter(),inpVal)\r\n        //*then we take created node and pass it to function dat will bring live for btns which r inside of passed node\r\n        initBtns(taskNode)\r\n    }\r\n\r\n    populateDoneTasks(input) {\r\n        const inpVal = input\r\n        const taskNode = document.createElement('li')\r\n        taskNode.classList.add('task')\r\n        taskNode.dataset.key = counterNegative()\r\n        taskNode.innerHTML = this.HTMLCode\r\n        tasksContainerDone.append(taskNode)\r\n        localStorage.setItem(counterNegative(),inpVal)\r\n    }\r\n}\r\nconsole.log('hello from todo')","//?ПОЛУЧЕНИЕ ЭЛЕМЕНТОВ-------------------------------------------------------------------\r\n//!get focus length input\r\nconst inputSession = document.querySelector('#focusTime')\r\n//!get pause length input\r\nconst inputPause = document.querySelector('#restTime')\r\n//!get time container\r\nconst timeContainer = document.querySelector('.time_container')\r\n//!get submit button\r\nconst submit = document.querySelector('.btn_submit')\r\n//!get pause switcher \r\nconst pauseSwitcher = document.querySelector('#pause_switcher')\r\n//!get whole clock div\r\nconst clockDiv = document.querySelector('.timer')\r\n//!get go back button\r\nconst goBack = document.querySelector('.btn_back')\r\n//!get timerForm\r\nconst timerForm = document.querySelector('.timer_form')\r\n//!get start session button\r\nconst startFocus = document.querySelector('.btn_start_focus')\r\n//!get start break button\r\nconst startRest = document.querySelector('.btn_start_rest')\r\n//!get stop button\r\nconst stop = document.querySelector('.btn_stop')\r\n\r\n//?ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ-----------------------------------------------------------------\r\n//!variable to store current time\r\nlet startTime;\r\n//!variable to store target time\r\nlet targetTime;\r\n//!variabe to store timer\r\nlet interval;\r\n//!variable to store focus session\r\nlet focusSession;\r\n//!variable to store rest session\r\nlet restSession;\r\n//!variable to store object w/ vars needed to reload\r\nlet obj = {};\r\n//!variable to store data id\r\nlet dataId;\r\n//!variable to store how many seconds pause was\r\nlet secondsOfPause = 0;\r\n//!variable to store pause timer\r\nlet pauseInterval;\r\n\r\n//? EVENTS-----------------------------------------------------------------------------------------------\r\n//!goback button\r\ngoBack.addEventListener('click', () => {\r\n    timerForm.style.display = 'flex'\r\n    clockDiv.style.display = 'none'\r\n    sessionStorage.clear()\r\n})\r\n\r\n//!submit button\r\n//getting user parameters\r\nsubmit.addEventListener('click', () => {\r\n    if (inputSession.value && inputPause.value) {\r\n        [focusSession, restSession] = [Number(inputSession.value), Number(inputPause.value)]\r\n        //clear input field after passing the value\r\n        inputSession.value = '';\r\n        inputPause.value = ''\r\n        timerForm.style.display = 'none'\r\n        clockDiv.style.display = 'flex'\r\n        saveRequiredData(focusSession,restSession,targetTime,dataId)\r\n    } else {\r\n        alert('Ты что-то не ввел походу')\r\n    }\r\n\r\n})\r\n\r\n//!startSession button\r\nstartFocus.addEventListener('click', (e) => {\r\n    startSession(focusSession,e)\r\n})\r\n\r\n//!startBreak button\r\nstartRest.addEventListener('click', (e) => {\r\n    startSession(restSession,e)\r\n})\r\n\r\n//!If pauseSwithcer active or not we do something\r\npauseSwitcher.addEventListener('click', () => {\r\n    if (pauseSwitcher.checked) {\r\n        //clearing interval and start to count seconds in paused state\r\n        clearInterval(interval)\r\n        wrapPauseCounter()\r\n    } else {\r\n        //clearing pause interval and updating targetTime\r\n        //then just call functions\r\n        clearInterval(pauseInterval)\r\n        secondsOfPause = secondsOfPause/60;\r\n        targetTime = addMinutes(targetTime,secondsOfPause)\r\n        saveRequiredData(focusSession,restSession,targetTime,dataId)\r\n        actualTimeLeft(targetTime,dataId)\r\n    }\r\n})\r\n\r\n//!Stop button making stoppin timer and preventin reload imunity\r\nstop.addEventListener('click', () => {\r\n    makeCLickable(dataId)\r\n    clearInterval(interval)\r\n    targetTime = 0;\r\n    timeContainer.innerHTML = '00:00'\r\n    saveRequiredData(focusSession,restSession,targetTime,dataId)\r\n})\r\n\r\n//!When page reloads we bringing back all needed parameters\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    if (sessionStorage.length > 1) {\r\n        timerForm.style.display = 'none'\r\n        clockDiv.style.display = 'flex'\r\n        assignRequiredData()\r\n        makeUnclickable(obj.dataID)\r\n        actualTimeLeft(targetTime,obj.dataID)\r\n    } else {\r\n        timerForm.style.display = 'flex'\r\n        clockDiv.style.display = 'none'\r\n    }\r\n})\r\n\r\n//?FUNCTIONS----------------------------------------------------------------\r\n//!Function that makes current time point and target time point\r\nfunction getEnds(period, act = (new Date)) {\r\n    startTime = act;\r\n    return targetTime = addMinutes(startTime,period)\r\n}\r\n\r\n//!Function that creates target time point\r\nfunction addMinutes(timePoint, minutes) {\r\n    if (minutes === 60) {\r\n        return new Date(timePoint.getTime() + (minutes**60*1000));\r\n    } else {\r\n        return new Date(timePoint.getTime() + minutes*60000);\r\n    }\r\n}\r\n\r\n//!Callback function for setInterval that displays time left before we get to target every second\r\nfunction actualTimeBeforeTarget (target, data, act = (new Date)) {\r\n        let diff = target.getTime() - act;\r\n        if (diff >= 0) {\r\n        timeContainer.innerHTML = new Date(diff).toLocaleTimeString(\"en-US\", {minute: '2-digit', second: '2-digit'});\r\n        } else if (diff = 0) {\r\n            timeContainer.classList.add('time_container_indication')\r\n        } else {\r\n            timeContainer.classList.add('time_container_indication')\r\n            clearInterval(interval)\r\n            makeCLickable(data)\r\n        }\r\n}\r\n\r\n//!Wrapper function for interval\r\nfunction actualTimeLeft(target,data,act) {\r\n    interval = setInterval(actualTimeBeforeTarget,1000,target,data,act)\r\n}\r\n\r\n//!Function that makes button clickable based on passed data-id\r\nfunction makeCLickable(data) {\r\n    switch (data) {\r\n        case 'focusSession':\r\n            startRest.disabled = false\r\n            break;\r\n        case 'restSession':\r\n            startFocus.disabled = false\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n//!Function that makes button unclickable based on passed data-id\r\nfunction makeUnclickable(data) {\r\n    switch (data) {\r\n        case 'focusSession':\r\n            startRest.disabled = true\r\n            break;\r\n        case 'restSession':\r\n            startFocus.disabled = true\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n//!Function that saves all important parameters as object and make it JSON, so I will be able to store in sessionStorage\r\nfunction saveRequiredData(focusTime,restTime,targetTime,dataID) {\r\n    obj = {\r\n        focusTime,\r\n        restTime,\r\n        targetTime,\r\n        dataID\r\n    }\r\n    obj = JSON.stringify(obj)\r\n    sessionStorage.setItem(1,obj)\r\n}\r\n\r\n//!Get object from sessionStorage and reassign exesting(but empty cuz of reload) variables\r\nfunction assignRequiredData() {\r\n    obj = sessionStorage.getItem(1)\r\n    obj = JSON.parse(obj)\r\n    obj.targetTime = new Date(obj.targetTime)\r\n    targetTime = obj.targetTime\r\n    focusSession = obj.focusTime\r\n    restSession = obj.restTime\r\n    dataId = obj.dataID\r\n}\r\n\r\n//!Function that counts how many second pause was\r\nfunction wrapPauseCounter() {\r\n    pauseInterval = setInterval(() => {\r\n        secondsOfPause++;\r\n    },1000)\r\n}\r\n\r\n//!Function to start particular session by clicking button\r\nconst startSession = (session, e) => {\r\n    dataId = e.currentTarget.dataset.id\r\n    makeUnclickable(dataId)\r\n    getEnds(session)\r\n    saveRequiredData(focusSession,restSession,targetTime,dataId)\r\n    actualTimeLeft(targetTime,dataId)\r\n    timeContainer.classList.remove('time_container_indication')\r\n}\r\nconsole.log('hello from timer')"],"names":["document","addEventListener","generateQuote","quoteURL","quoteContainer","querySelector","authorContainer","src","fetch","response","json","data","textContent","content","author","console","log","count","inputField","pullToList","tasksContainer","tasksContainerDone","clearDoneTasks","counter","Math","max","localStorage","length","keysStore","Object","keys","higherKey","counterNegative","min","lowerKey","generateNegativeUniqueKey","populateTask","input","HTMLCode","Task","populateTasks","initBtns","lazyTask","doneTask","deleteTask","taskText","e","preventDefault","classList","toggle","populateDoneTasks","populateDoneTask","deleteNodeTask","event","target","currentTarget","parentNode","contains","remove","removeItem","dataset","key","alert","value","keyCode","store","filter","x","sort","i","getItem","taskNodeRe","createElement","add","skeleton","innerHTML","append","querySelectorAll","forEach","task","repopulateTasks","repopulateDoneTasks","this","inpVal","taskNode","setItem","targetTime","interval","focusSession","restSession","dataId","pauseInterval","inputSession","inputPause","timeContainer","submit","pauseSwitcher","clockDiv","goBack","timerForm","startFocus","startRest","stop","obj","secondsOfPause","addMinutes","timePoint","minutes","Date","getTime","actualTimeBeforeTarget","act","diff","toLocaleTimeString","minute","second","clearInterval","makeCLickable","actualTimeLeft","setInterval","disabled","makeUnclickable","saveRequiredData","focusTime","restTime","dataID","JSON","stringify","sessionStorage","style","display","clear","startSession","checked","parse","session","id","period","getEnds"],"sourceRoot":""}